# LR0Parser

**学号:** 202003340111 

**姓名:** 李肖

## 算法过程

### 1. 读取文法

读取文法的过程中，将文法的每一条产生式都转换为一个`Production`对象，然后将这些对象存储在`productions`列表中。

### 2. 构造项目集规范族

#### 2.1 构造初始项目集

初始项目集就是文法的开始符号的产生式的项目集，即`I0`。其中我们放入构造增广文法中的产生式`S' -> S`的项目。

#### 2.2 构造闭包

对于一个项目集`I`，我们需要构造它的闭包`Closure(I)`。对于一个项目`A -> a.Bb`，我们需要将所有`B -> .c`的产生式都加入到项目集中，其中`c`是`B`的一个终结符或非终结符。如果`B`是一个非终结符，我们还需要将`B`的所有产生式都加入到项目集中。

#### 2.3 构造转移函数

对于一个项目集`I`，我们需要构造它的转移函数`GOTO(I, X)`，其中`X`是一个终结符或非终结符。对于一个项目`A -> a.Bb`，如果`X = B`，我们需要将`B -> .c`的产生式都加入到`GOTO(I, X)`中，其中`c`是`B`的一个终结符或非终结符。如果`B`是一个非终结符，我们还需要将`B`的所有产生式都加入到`GOTO(I, X)`中。

#### 2.4 构造项目集规范族

我们从初始项目集`I0`开始，通过枚举所有的符号，然后构造当前的项目集合利用当前枚举出来的符号通过 `GOTO` 函数转移到的集合，加入到自动机中。然后我们对于新加入的项目集合，继续枚举所有的符号，然后构造当前的项目集合利用当前枚举出来的符号通过 `GOTO` 函数转移到的集合，加入到自动机中。我们重复这个过程，直到没有新的项目集合加入到自动机中。

### 3. 构造分析表

#### 3.1 构造ACTION表

首先我们先枚举所有的状态，然后再枚举所有的终结符。对于一个状态`I`和一个终结符`a`，如果`GOTO(I, a)`是一个状态`J`，并且`a`不是`$`，我们将`ACTION[I, a]`设置为`shift J`。如果`a`是`$`，我们将`ACTION[I, a]`设置为`accept`。如果当前状态`I`中有一个项目`A -> a.`，我们将`ACTION[I, a]`设置为`reduce A -> a`。

#### 3.2 构造GOTO表

首先我们先枚举所有的状态，然后再枚举所有的非终结符。对于一个状态`I`和一个非终结符`A`，如果`GOTO(I, A)`是一个状态`J`，我们将`GOTO[I, A]`设置为`J`。

## 运行结果

![aw8Cja](https://picture-1303128679.cos.ap-shanghai.myqcloud.com/uPic/aw8Cja.png)

```
        a       b       c       d       #       A       B       E       S
0       s3      s4                                              1       2
1       r0      r0      r0      r0
2                                       accept
3                       s6      s7              5
4                       s9      s10                     8
5       r1      r1      r1      r1
6                       s6      s7              11
7       r4      r4      r4      r4
8       r2      r2      r2      r2
9                       s9      s10                     12
10      r6      r6      r6      r6
11      r3      r3      r3      r3
12      r5      r5      r5      r5                                      
```